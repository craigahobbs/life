<!DOCTYPE html>
<!--
Licensed under the MIT License
https://github.com/craigahobbs/life/blob/master/LICENSE
-->
<html lang="en">
    <head>
        <title>Conway's Game of Life</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>

html, body, div, span, h1, h2, h3 p, a, table, tr, th, td, ul, li, p {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    font-size: 1em;
    vertical-align: baseline;
}
body, td, th {
    background-color: white;
    font-family: 'Helvetica', 'Arial', sans-serif;
    font-size: 10pt;
    line-height: 1.2em;
    color: black;
}
body {
    margin: 1em;
}
h1, h2, h3 {
    font-weight: bold;
}
h1 {
    font-size: 1.6em;
    margin: 1em 0 1em 0;
}
h2 {
    font-size: 1.4em;
    margin: 1.4em 0 1em 0;
}
h3 {
    font-size: 1.2em;
    margin: 1.5em 0 1em 0;
}
table {
    border-collapse: collapse;
    border-spacing: 0;
    margin: 1.2em 0 0 0;
}
th, td {
    padding: 0.5em 1em 0.5em 1em;
    text-align: left;
    border-style: solid;
    border-width: 2px;
}
th {
    font-weight: bold;
}
p {
    margin: 0.5em 0 0 0;
}
p:first-child {
    margin: 0;
}

        </style>
    </head>
    <body>
    </body>
    <script>

function lifePage(parent) {
    let params = decodeParams(),
        size = params.size ? parseInt(params.size) : 9,
        width = params.width ? parseInt(params.width) : 50,
        height = params.height ? parseInt(params.height) : 50,
        threshold = params.threshold ? parseFloat(params.threshold) : 0.25,
        period = params.period ? parseFloat(params.period) : 1,
        reset = params.reset ? params.reset === 'true' || params.reset === '1' : false,
        play = params.play ? params.play === 'true' || params.play === '1' : true;

    // Generate random cells, if necessary
    if (gCells === null) {
        gCells = randomCells(width, height, threshold);
    } else {
        let [cellsWidth, cellsHeight] = getCellsWidthHeight(gCells);
        if (width !== cellsWidth || height !== cellsHeight) {
            gCells = randomCells(width, height, threshold);
        }
    }

    // Render
    render(parent, [
        // Title
        elem('p', {'style': 'white-space: nowrap;'}, [
            elem(
                'span',
                {'style': 'font-weight: bold;'},
                text("Conway's Game of Life")
            ),
            text(nbsp + nbsp + nbsp),
            elem('a', {'href': 'https://github.com/craigahobbs/life', 'target': '_blank'}, text('Instructions')),
            text(nbsp + nbsp + nbsp),
            elem('a', {'href': 'https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life', 'target': '_blank'}, text('Wikipedia')),
        ]),
        elem('p', {'style': 'white-space: nowrap;'}, [
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'reset': '1'}))}, text('Reset')),
            text(nbsp + nbsp + nbsp),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'play': play ? '0' : '1'}))}, text(play ? 'Pause' : 'Play')),
            text(nbsp + nbsp + nbsp + '('),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'period': period * 2}))}, text('Slower')),
            text(nbsp + endash + nbsp),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'period': period / 2}))}, text('Faster')),
            text(')' + nbsp + nbsp + nbsp + '('),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'width': Math.max(10, width - 10)}))}, text('Width-')),
            text(nbsp + endash + nbsp),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'width': width + 10}))}, text('Width+')),
            text(')' + nbsp + nbsp + nbsp + '('),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'height': Math.max(10, height - 10)}))}, text('Height-')),
            text(nbsp + endash + nbsp),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'height': height + 10}))}, text('Height+')),
            text(')' + nbsp + nbsp + nbsp + '('),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'size': Math.max(2, size - 1)}))}, text('Size-')),
            text(nbsp + endash + nbsp),
            elem('a', {'href': href(Object.assign(Object.assign({}, params), {'size': size + 1}))}, text('Size+')),
            text(')'),
        ]),

        // Life SVG
        elem('p', {'id': 'lifeSvg'}, lifeSvg(params, size, gCells))
    ]);

    // Set the generation interval
    if (gInterval !== null) {
        clearInterval(gInterval);
        gInterval = null;
    }
    if (reset) {
        gCells = randomCells(width, height, threshold);

        // Redirect without reset param
        let redirectParams = Object.assign({}, params);
        delete redirectParams.reset;
        window.location.href = href(redirectParams);
    } else if (play) {
        gInterval = setInterval(function() {
            let cellsPrev = gCells;
            gCells = getNextCells(gCells);
            if (cellsEqual(gCells, cellsPrev)) {
                gCells = randomCells(width, height, threshold);
            }
            render(document.getElementById('lifeSvg'), lifeSvg(params, size, gCells));
        }, period * 1000);
    }
}

function lifeSvg(params, size, cells) {
    let [width, height] = getCellsWidthHeight(cells),
        gap = params.gap ? parseInt(params.gap) : 1,
        svgWidth = gap + width * (size + gap),
        svgHeight = gap + height * (size + gap),
        fill = params.fill || '#2a803b',
        stroke = params.stroke || 'none',
        strokeWidth = params.strokeWidth || '1',
        bgFill = params.bgFill || '#ffffff',
        bgStroke = params.bgStroke || 'none',
        bgStrokeWidth = params.bgStrokeWidth || '1',
        cellElems = [],
        svgElems = svgElem('svg', {'width': svgWidth, 'height': svgHeight}, cellElems);

    // Background
    cellElems.push(svgElem('rect', {
            'x': '0',
            'y': '0',
            'width': svgWidth,
            'height': svgHeight,
            'style': 'fill: ' + bgFill + '; stroke: ' + bgStroke + '; stroke-width: ' + bgStrokeWidth + ';'
    }));

    // Cells
    for (let iy = 0; iy < height; iy++) {
        for (let ix = 0; ix < width; ix++) {
            if (getCell(cells, ix, iy)) {
                cellElems.push(svgElem('rect', {
                    'x': gap + ix * (size + gap),
                    'y': gap + iy * (size + gap),
                    'width': size,
                    'height': size,
                    'style': 'fill: ' + fill + '; stroke: ' + stroke + '; stroke-width: ' + strokeWidth + ';'
                }));
            }
        }
    }

    return svgElems;
}

function randomCells(width, height, threshold) {
    let cells = [];
    for (let iy = 0; iy < height; iy++) {
        let row = [];
        cells.push(row);
        for (let ix = 0; ix < width; ix++) {
            row.push(Math.random() < threshold);
        }
    }
    return cells;
}

function getCellsWidthHeight(cells) {
    return [cells[0].length, cells.length];
}

function cellsEqual(cells1, cells2) {
    if (cells1.length !== cells2.length) {
        return false;
    }
    for (let iy = 0; iy < cells1.length; iy++) {
        if (cells1[iy].length !== cells2[iy].length) {
            return false;
        }
        for (let ix = 0; ix < cells1[iy].length; ix++) {
            if (cells1[iy][ix] !== cells2[iy][ix]) {
                return false;
            }
        }
    }
    return true;
}

function getNextCells(cells) {
    return cells.map(function(row, iy) {
        return row.map(function(value, ix) {
            return getNextCell(cells, ix, iy);
        });
    });
}

function getCell(cells, ix, iy) {
    if (ix < 0 || iy < 0 || iy >= cells.length || ix >= cells[iy].length) {
        return false;
    }
    return cells[iy][ix];
}

function getNextCell(cells, ix, iy) {
    let count =
        getCell(cells, ix - 1, iy - 1) +
        getCell(cells, ix, iy - 1) +
        getCell(cells, ix + 1, iy - 1) +
        getCell(cells, ix - 1, iy) +
        getCell(cells, ix + 1, iy) +
        getCell(cells, ix - 1, iy + 1) +
        getCell(cells, ix, iy + 1) +
        getCell(cells, ix + 1, iy + 1);

    if (getCell(cells, ix, iy)) {
        return count === 2 || count === 3;
    }
    else {
        return count === 3;
    }
}

function main(parent) {
    // Listen for hash parameter changes
    window.onhashchange = function () {
        main(parent);
    };

    // Render page
    lifePage(parent);
}

// ======================================================================

const nbsp = String.fromCharCode(160);
const endash = String.fromCharCode(8211);

function render(parent, elems, clear=true) {
    if (clear) {
        parent.innerHTML = '';
    }
    return appendNodes(parent, elems);
}

function node(elem) {
    let node_ = elem.text ? document.createTextNode(elem.text) : document.createElementNS(elem.ns, elem.tag);
    if (elem.attrs) {
        for (let attr in elem.attrs) {
            let value = elem.attrs[attr];
            if (value) {
                node_.setAttribute(attr, value);
            }
        }
    }
    return appendNodes(node_, elem.elems);
}

function appendNodes(parent, elems) {
    if (Array.isArray(elems)) {
        for (let iElem = 0; iElem < elems.length; iElem++) {
            appendNodes(parent, elems[iElem]);
        }
    } else if (elems) {
        parent.appendChild(node(elems));
    }
    return parent;
}

function elem(tag, attrsOrElems, elems, ns) {
    let attrs = isDict(attrsOrElems) ? attrsOrElems : undefined;
    return {
        tag: tag,
        attrs: attrs || {},
        elems: (attrs ? elems : attrsOrElems) || [],
        ns: ns || 'http://www.w3.org/1999/xhtml'
    };
}

function svgElem(tag, attrsOrElems, elems) {
    return elem(tag, attrsOrElems, elems, 'http://www.w3.org/2000/svg');
}

function text(text_) {
    return {
        text: text_,
    };
}

function href(hashParams, params, path) {
    hashParams = encodeParams(hashParams);
    params = encodeParams(params);
    path = path ? path : window.location.pathname;
    if (hashParams === null && params === null) {
        return path + '#';
    } else if (hashParams === null && params !== null) {
        return path + '?' + params;
    } else if (hashParams !== null && params === null) {
        return path + '#' + hashParams;
    }
    return path + '?' + params + '#' + hashParams;
}

function encodeParams(params) {
    let items = [];
    if (undefined !== params) {
        let name;
        for (name in params) {
            if (params[name] !== null) {
                items.push(encodeURIComponent(name) + '=' + encodeURIComponent(params[name]));
            }
        }
        for (name in params) {
            if (params[name] === null) {
                items.push(encodeURIComponent(name));
            }
        }
    }
    return items.length ? items.join('&') : null;
}

function decodeParams(paramString) {
    let params = {},
        r = /([^&;=]+)=?([^&;]*)/g,
        d = function (s) { return decodeURIComponent(s.replace(/\+/g, " ")); },
        q = (paramString || window.location.hash.substring(1)),
        e;

    while ((e = r.exec(q)) !== null) {
        params[d(e[1])] = d(e[2]);
    }

    return params;
}

function isDict(obj) {
    return !!obj && obj.constructor == Object;
}

// ======================================================================

let gCells = null,
    gInterval = null;

main(document.body);

    </script>
</html>
